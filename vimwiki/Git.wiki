= Git cheatsheet =

NOTE: git commands with different behavior than their subcommands should list
the full git <command> <subcommand> to avoid implying that the subcommand is a
extension to the behavior of the base command listed on the RHS. The same
applies for flags.

git config <option> <value>     Set <option> to <value>
git config <option>             Get value of <option>
git config -l                   Get value of all options
    --show-origin               Show source of each listed option's value

git config --global alias.co checkout               Alias a git command
git config --global alias.unstage 'reset HEAD --'   And another
git config --global alias.visual '!gitk'        External commands require "!"

git help <command>     Show help for <command>
git <command> --help   Show help for <command>
man git-<command>      Show help for <command>

git init   Initialize a new repository in the current dir

git add <file>    Track or stage changes in <file>
git add -A        Track or stage changes for all files

git commit      Record the index in the .git repository
    -m          Inline commit message
    -v          Include diffs in editor for ref when writing message
    -a          Stage all unstaged changes before committing
    --amend     Replace previous commit with current staging area

git rm <file>       Stage file for untracking and deletion. File globbing can be
                    used in <file>.
    -f              Forcing needed when file is modified or staged
    --cached        Untrack but don't delete file

git mv SRC DST      Rename SRC to DST. Equiv. to mv SRC DST; git rm SRC; git add
                    DST. Git will record this as a rename.

git status      Show current branch, its status relative to its remote-tracking
                branch, which changes are staged, and untracked files untracked
                files, and which changes are staged
    -s          Shorthand git status, with ?? for untracked, A for newly tracked
                ("added"), " M" for modified-unstaged, "M " for modified-staged,
                MM for staged and unstaged modifications.
    -b          In short status, show branch info
    -v[v]       Show staged [and unstaged] changes additionally, like git diff
                --cached [mixed with git diff] output

git diff                    Diff b/w working tree and index
    --cached | --staged     Diff b/w index and prior commit

git log                 Commit history
    --all               Show commits from all refs. Apparently the current
                        branch is the only one shown by default.
    -p                  Show patch introduced by each commit
    --stat              Show stats about # of lines changed in each file
    --pretty=FORMAT a   Pretty-print in the given FORMAT, which is one of
                        oneline, short, medium, full, fuller, email, raw,
                        format:STRING, and tformat:STRING
    --graph             ASCII graph of branch and merge history
    --decorate          Print references (local and remote) next to commits
    --abbrev-commit     Shortened SHA-1
    --name-status       Show filenames and change status for each commit. Status
                        codes are the same as for --diff-filter
    --oneline           Equiv. to --pretty=oneline --abbrev-commit
    -S STRING           Filter commits to those in which STRING's # of occurences
                        have changed (e.g., function definition)
    --pickaxe-regex     STRING passed to -S is POSIX extended regex
    -G REGEX            Filter commits to those with added/removed lines
                        containing REGEX, even if # occurences hasn't changed
                        (e.g., if REGEX was both added and removed on a line -G
                        and not -S will match it).
    --pickaxe-all       Show all changes for commit rather than just changes for
                        files(s) containing the changes matched by -G or -S. Only
                        seems to work in combination with -p.
    -<n>                Limit to <n> commits
    --since=<date>      Filter out commits before date
    --until=<date>      Filter out commits after date

git log --oneline --decorate --graph --all
    Visualize your git history w/ branches

git reset [<paths>]     Unstage <paths> if specified, else reset the index

git remote                  Show remote servers by shortname
    -v                      Additionally show repository locations (typically
                            URLs)
git remote show <remote>    More info on remote
git remote add <name> <url> Add remote <name> for the repository at <url>. Then
                            git fetch will create and update remote-tracking
                            branches <name>/<branch>
git remote rm                       Remove remote
git remote rename <old> <new>       Rename remote

git ls-remote       List remote references (e.g., branches)

git fetch (<remote> | -all)     Fetch branches and/or tags ("refs") from
                                <remote> or all remotes, along with the objects
                                needed to complete their histories. Updates
                                remote-tracking branches.

git pull    Fetch and merge from the upstream remote-tracking branch

git push                    Update remote using local refs, while sending
                            objects necessary to complete the given refs. By
                            default the current branch is pushed to its upstream
    <remote> <branch>       Push branch to remote
    <remote> --tags         Push all tags to remote
    <remote> <tag>          Push tag to remote
    <remote> --delete <tag>     Delete remote tag
    <remote> :refs/tags/<tag>   Delete remote tag (interpret as pushing null
                                value (LHS of :) to remote tagname (RHS)

git clone <repo> <dir>  Clone repository located at <repo> to a directory named
                        after the repository. Creates a remote named origin
                        pointing to the repository. Sets origin/master as the
                        upstream branch for master such that git push and pull
                        on master use origin/master by default. If <dir> is
                        omitted, a dir is created from the repository name.

git tag                     List all tags
    -l "v1.8.5*"            List tags beginning with "v1.8.5"
    <tag> <commit>          Create lightweight tag. If <commit> is omitted, tag
                            HEAD
    -d <tag>                Delete local tag
    -a <tag> -m <message> <commit>  Create annotated tag with message at
                                    <commit> or by default HEAD

git show        Show various objects
    <tag>       Show tag's commit (and annotation, if one exists)
    <commit>

git checkout
    -- <paths>              Discard modifications to <paths>. NOTE: Cannot be
                            reversed. Even deleted branches or amended commits
                            can be recovered, but not discarded changes that
                            were never committed.
    <branch>                Switch branches (i.e., point HEAD to <branch>)
    -b <branch> [<object>]  Create and switch to branch at <object> (by default
                            HEAD).
    <tag>                   Checkout tag in detched HEAD state

git branch          List branches (`*` indicates current branch)
    -v              Also list SHA-1 and message of commit for current branch
    --merged|--unmerged <branch>    View branches merged or not into <branch> or
                                    the current branch by default. Merged
                                    branches are candidates for deletion.
    <branch>        Create a new branch
    -d <branch>     Delete a branch after merging. Fails if the branch has
                    not been merged into HEAD, assuming it has no upstream
    -D <branch>     Force deletion of branch



git merge <branch>: Merge <branch> with the current branch. E.g., checkout your
master branch, then merge the other branch into master.






git clone -o <remote>: Clone a repository and change the remote name from the
default "origin" to something else.

git fetch <remote>: Fetch data from new commits since last fetch/pull/clone, and
update remote-tracking branches to reflect new state of the tracked remote
branches.

git push <remote> <branch>: Push branch to remote repo. Shorthand for git push
<remote> refs/heads/<branch>:refs/heads/<branch>, where LHS is local and RHS is
remote. The longhand syntax allows different branch names locally than remotely.
A slighly shorter longhand is git push <branch>:<branch>.


Note that fetching doesn't create a new local branch when new remote-tracking
branches are created. To checkout a branch from a remote-tracking branch, use
`git checkout -b <branch> <remote>/<branch>`.
This new branch is known as a "tracking" branch. The remote-tracking branch is
then known as the upstream branch. Enables `git pull` and `git push` on the
tracking branch. `git clone` automatically creates a tracking branch.
Shorthand for the above is
`git checkout --track <remote>/<branch>`,
which will create local tracking branch `<branch>`.
Additional shorthand is
`git checkout <branch>`,
which creates a tracking branch if `<branch>` doesn't exist and exactly matches
a name on only one remote.

If you already have a local branch and want to set or change its upstream
branch:
`git branch -u <remote>/<branch>`

git branch -vv: Show tracking branches, the remote branches they track, and
whether tracking branch is ahead or behind remote branch

git fetch --all: Fetch from all remotes

Note that git fetch does not modify working directory. You still have to
checkout local branches from remote ones or merge in changes from the remote
branches to existing local branches.
git pull fetches and tries to merge.

git push <remote> --delete <branch>: Delete a remote branch once it's been
merged into another remote branch. This removes the pointer, and the data that
was pointed to remains until garbage collection.





= Configuration =

Configuration of git happens through .gitignore and .gitconfig. The latter can
be edited via the `git config` command. This is also the command for creating
command aliases.

These files can exist at the system (all users), global (current user), and
local (repository) level. Local configuration overrides global, which overrides
system configuration.

== gitignore ==

Syntax:
    * standard globbing is recursively applied
        * *: Zero or more characters
        * []: One of the characters within brackets
        * ?: A single character
        * [0-9]: Characters within range (e.g., 0 through 9)
        * **: Zero or more directories
            * E.g., a/**/z matches a/z, a/b/z, a/b/c/z, etc.
    * Beginning / avoids recursion
    * Ending / specifies directory
    * ! negates pattern
    * # comments

.gitignore files can be placed within subdirectories of repo. See man
.gitignore for specifics.
.gitignore templates: https://github.com/github/gitignore

= What is Git? =

Git is a distributed VCS that stores a snapshot of repository state (i.e., file
state) rather than file diffs.

Git operations are quick because they are done locally.

When you are ready to send local work to a remote repository, Git transfers your
work via one of four protocols: http, git, ssh, and local. Most people
interact with remote repositories through a repository hub like GitHub, using
the http protocol, the repository's URL, and user credentials to determine
access permissions.

Git uses unique SHA-1
[[https://ericsink.com/vcbe/html/cryptographic_hashes.html|checksum-hashes]] to
store and reference content. These serve as keys for data-lookup and as checks
to ensure that data integrity is preserved.

Files have two Git states: tracked and untracked. Tracked files are those that
have previously been committed and have not been explicitly untracked later.

A git-tracked file has three states:
    * Modified: File in the working tree has changes but isn't committed.
    * Staged: Modified file has been marked for commit by inclusion in the
      index/staging-area file of the .git dir. A file can be both staged and
      modified if only some changes to it have been staged.
    * Committed: Changed file has been stored as an object in the .git dir.
      After this, new changes will make the file as modified.

The basic workflow of Git is:

Start or clone a repository         `git clone`
Edit files
Add edits to be stored              `git add <paths>`
Commit edits                        `git commit`
Add a remote                        `git remote add <name> <url>`
Fetch remote data                   `git fetch <remote>`
Merge in remote changes             `git merge <remote>/<branch>`
Push work to remote repo            `git push`

TODO: Add other basic commands like creating and checking out branches

= Objects and references =

Pointers: files that only contain the SHA-1 hashes of Git objects (e.g.,
commits). Seems to be a synonym for reference, but the latter term often seems
to be used when describing specific types of pointers.

== Objects ==

Git has various types of objects:
    * Blobs are basically files.
    * Trees are directories. They record pointers to the blobs (files) and
      subtrees within, as well as the names associated with each SHA-1 pointer.
      For files that haven't changed since a previous commit, the pointer
      continues to point to the blob in a previous commit.
    * Commits are like repository snapshots. Commit objects record the author,
      committer, commit message, a pointer to the parent commit(s) (multiple for
      merges, none for initial commit), and a pointer to the root tree object of
      the snapshot.

== References ==

=== Tags ===

Tags are static pointers to commits. There are two types:
    * Lighweight: SHA-1 pointers to commits--like a branch but static
    * Annotated: Contain additional metadata and can be signed with GPG

Tags must be explicitly pushed to a remote, since they are not pushed by
default.

== Branches ==

Branches are lightweight, movable pointers to a commit. The default branch name
is `master`. As you make commits, the current branch updates to point at the last
commit made. So if you create a new branch, switch to it, and make a new commit,
only the new branch will point to the most recent commit. Git tracks the current
branch via the special pointer `HEAD`. To change the current branch, use
`git checkout`.

Before switching branches, you either need to commit or stash changes. You can
always do a commit amend when you switch back, if you don't want to stash.

=== Merging branches ===

Branches are used by Git to split work into different topics or for different
groups. Once the work is finished, it is typical to merge it into another branch
via git merge. When the current branch is an ancestor of the merged branch, this
is a fast-forward merge. No new commit is created, and the current branch moves
up to point at the commit pointed to by the merged branch.

An example of this is `git-fetch` in which a remote branch has moved forward.
`git status` will report that your branch is behind the remote-tracking branch by
N commits. Assuming you're on `master` and tracking `origin/master`, you could do
one of:
    * `git pull`
    * `git merge origin/master`

After merging a branch, it is typical to delete it. Its commits are recorded in
history, and a new branch can be spawned at any point along the branch's
previous history if e.g. code fixes are later needed.

For two divergent branches with a common ancestor, a three-way merge is done and
a new commit is created for the resulting snapshot.

=== Merge conflict resolution ===

If the branches to be merged have different changes to the same lines in a file,
a merge conflict arises. To view which files have conflicts after a merge, run
git status. Files with conflicts are listed as unmerged. Git adds conflict
markers to the files. Open the files in an editor:

{{{
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
}}}

Replace these lines with the desired code. After exting your editor, Git asks if
the merge was successful. If you say yes, git will stage the changes.  Running
git commit concludes the merge. Include a message that explains the rationale
for the way you resolved the conflict(s).

If configured, git mergetool can be used to resolve merge conflicts.

TODO: Research difftools for MacOs, Linux, and Windows

== Remotes ==

Remotes: Remote repositories, usually identified by a name that resolves to the
repository URL.

Remote references: References contained in a remote repository.

Remote-tracking branches: Local references indicating the state of remote
branches at the time of last network communication. Git moves them whenever you
communicate with remotes via `git fetch`. Have the form `<remote>/<branch>`.
Created automatically during cloning.

Remote branches: Sometimes used by Git Pro to indicate remote-tracking branches.
Technically, remote-tracking branches track the state of remote branches, and
inbetween running `git fetch`, the two may point to different commits.

Note that fetching doesn't create a new local branch when new remote-tracking
branches are created. To checkout a branch from a remote-tracking branch, use
`git checkout -b <branch> <remote>/<branch>`.
This new branch is known as a "tracking" branch. The remote-tracking branch is
then known as the upstream branch. Enables `git pull` and `git push` on the
tracking branch. `git clone` automatically creates a tracking branch.
Shorthand for the above is
`git checkout --track <remote>/<branch>`,
which will create local tracking branch `<branch>`.
Additional shorthand is
`git checkout <branch>`,
which creates a tracking branch if `<branch>` doesn't exist and exactly matches
a name on only one remote.

If you already have a local branch and want to set or change its upstream
branch:
`git branch -u <remote>/<branch>`

git branch -vv: Show tracking branches, the remote branches they track, and
whether tracking branch is ahead or behind remote branch

git fetch --all: Fetch from all remotes

Note that git fetch does not modify working directory. You still have to
checkout local branches from remote ones or merge in changes from the remote
branches to existing local branches.
git pull fetches and tries to merge.

git push <remote> --delete <branch>: Delete a remote branch once it's been
merged into another remote branch. This removes the pointer, and the data that
was pointed to remains until garbage collection.

== Rebasing ==

Alternative to three-way merges. Rather than merging two divergent branches into
a single descendant commit, you can apply the changes from the current branch
onto a target branch (e.g., master):
git checkout <branch>
git rebase master

"This operation works by going to the common ancestor of the two branches (the
one you’re on and the one you’re rebasing onto), getting the diff introduced by
each commit of the branch you’re on, saving those diffs to temporary files,
resetting the current branch to the same commit as the branch you are rebasing
onto, and finally applying each change in turn."

After rebase, you checkout the target branch and do a fast-forward merge to the
commit created by the rebase and now identified by the branch that was checked
out when you rebased (this branch was moved to the new forward commit).
git checkout master
git merge <brach>

Rebasing produces the same end commit but with a cleaner, linear log.

Complex rebasing is possible. E.g., a third branch sharing an ancestor commit
with a second branch whose parent is a commit in the master branch.
git rebase --onto master <second> <third>
git checkout master
git merge <third>
This ignores the commits from second that third does not share and rebases
third's commits onto master.
https://git-scm.com/book/en/v2/ch00/rbdiag_e

git rebase <first> <second>: Rebase second branch onto first (target) branch
without having to checkout second. After this, you still need to checkout the
first branch if not yet checked out, then merge the second branch.

!!!Warning!!! Do not rebase commits that exist remotely, which others may have
based their work on. The example near the bottom of
https://git-scm.com/book/en/v2/Git-Branching-Rebasing#rbdiag_i contains a fix
that may work if this occurs.

In general, rebase local changes that haven't been pushed to maintain a clean
history, and never rebase if you've pushed. If rebase isn't avialable, there's
always merge.

= Git on the server =

== Transfer Protocols ==

=== Local ===

For when the remote repository is in another directory on the same host. Can be
used e.g. for a team with access to a shared filesystem such an NFS mount.
Cloning, pushing, and pulling can be done as usual, but there are two syntaxes.

git clone /srv/git/project.git
git clone file:///srv/git/project.git


Without the file:// prefix, git clone operates as if the --local flag was
passed: the contents of .git/objects are hardlinked, and the "Git aware"
transport mechanism is bypassed. --no-local forces the regular Git transport.
--no-hardlinks forces copying of .git/objects instead of hardlinking. The first
syntax is faster than the second.

Because hardlinking creates a duplicate file pointing to the same inode (file
contents), it should be safe to use hardlinks so long as no one deletes the
remote repository on the shared drive. Deleting anything within the local
.git/objects directory will simply delete the local file rather than the file
contents.

Note that the local protocol uses existing file permissions and shared access
settings. It may be slower to use the local protocol on a shared mount than to
use the SSH protocol.

=== HTTP ===

By default, smart HTTP allows users to pull and push from a single URL with user
authentication enabled for either read or write access. Anonymous access is
possible.

Source: https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F

=== SSH ===

Standard SSH syntax:
git clone ssh://[user@]server/project.git
SCP-like syntax:
git clone [user@]server:project.git
If the optinal username is omitted, Git assumes the current user.

Unlike HTTP, does not support anonymous access to a Git repository that you
self-host. To access, users need at least read access to the repository, but
this may be a feature for internal corporate settings.

=== Git ===

Similar to SSH without authentication. Uses a dedicated network port (9418).
Requires some initial setup for each repository for the Git daemon to enable
this protocol.

== Setting up a server ==

For serving an existing repo:
git clone --bare <repo> <dirname>.git
This is roughly (not exactly) equivalent to
cp -Rf <repo>/.git <dirname>.git

For an empty server:
cd <parent-dir>
mkdir <dirname>.git
cd <dirname>.git
git init --bare

Then from your local repoistory:
git remote add origin <paren-dir>/<repo>

Now you can push and pull to the remote.

You can alter filesharing permissions and send the repo path to whoever wishes
to clone it. This works for shared drives atthe very least. Inspired by:
https://medium.com/@piteryo7/how-to-set-up-git-server-on-local-network-windows-tutorial-7ec5cd2df3b1

Alternatively, you can setup SSH for certain users and manage their permissions.
For shared drives, you probably don't need SSH and can stick to the local
transfer protocol. For SSH, see 4.2 onward of
https://www.vogella.com/tutorials/GitHosting/article.html.

For more information on server setup, see Chapter 4 of Git Pro.

TODO: Can probably just copy the VOC inventory (git repo for scripts and all)
entirely back and forth from D:, until others begin to collaborate on it. Then
the repo needs to be setup as a bare repository on the shared drive, possibly
even with SSH configuration.
TODO: Does the local protocol apply to our shared drives at work? It should if
they are NFS mounts.
TODO: Look into setting access permissions from file browser and for different
shells on Windows (but git-bash in particular) for a bare repository on a shared
drive. If others are collaborating, we need some way to prevent them from
modifying A:/VOC/Inventories from the file browser AND from the shell.
Especially any git repos within there.
TODO: When adding a remote on a shared drive, do I have to use the UNC paths
(i.e., //dprhq01/...) or can I use drive letters? If the former, do I have to
use pushd and popd to navigate in the shell? Test pushing and pulling within git
bash after adding a remote repo on a shared mount to see if UNC paths work fine.
TODO: For Windows git, make sure to select the option to "Checkout Windows-style,
commit Unix-style line endings."
TODO: Learn DVC (https://dvc.org) for data versioning

= Distributed Git =

== Distributed workflows ==

There are several Git development workflows.

1. Centralized workflow. Everyone pushes and pulls to and from a shared
   repository, and before pushing each developer needs to ensure there
   repository is at the latest state, or merge in the others' changes, before
   pushing their own work.
2. A canonical repository exists. Most people have read access to this and write
   access to their own public copy of it. A contributor emails the canonical
   repo manager. That person adds the contributor repo as a remote, tests their
   code, merges to their own local copy, then pushes to the canonical repo.
3. The second step can involve tiered management, in which one or more managers
   have sub-managers, and below this are topic developers. Sub-managers test and
   merge topic branches from developers, and managers do the same for
   sub-managers, pushing to the canonical repo when ready.

== Contributing to a project ==

=== Commit Guidelines ===

Tips from the git project on commits:
https://github.com/git/git/blob/master/Documentation/SubmittingPatches

1) Check for whitespace errors:
    a) git diff --check
2) Keep commits small. If needed, stage only parts of a changed file:
    a) git add --patch
3) Commit messages
    a) Limit subject lines to 50 characters or less
    b) Blank line follows
    c) Explanatory text wrapped at 72 characters or less. Write in the
       imperative mood: "Fix bug," not "Fixed" or "Fixes bug." Multiple
       paragraphs or bullet points can be separated by blank lines. Use hyphens
       or asterisks and hanging indents for bullets.

=== Private Projects ===

See [[https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project|section 5.2 of Git Pro]] for detailed examples of developing with git, with
images.

Someone pushes work to the remote, and you want to see what new commits they've
introduced (i.e., what you'll have to merge).
git fetch origin
git log issue54..origin/master
This uses a log filter to get commits on the latter branch that are not on the
first branch. Here, issue54 is a local branch you're workign on. Note that the
latter branch is a remote-tracking branch, which is why we ran git fetch first.
This enables you to examine the work before merging it into your local repo.
From here you would merge your topic branch into your local master, then fetch
and merge the remote master branch, then push to the remote.

git push -u origin <topic>: Creates the topic branch on the remote, pushes the
contents, and adds a remote-tracking branch locally.

If two people have independently created branches for a topic (and likely given
them different names), after pulling their branch down you could either merge
your branch into theirs and push normally, or merge their branch (featureBee)
into yours (featureB) and push your local branch to the differently named remote
branch
git push -u origin featureB:featureBee

=== Forked public project ===

Process used on GitHub where push access is restricted.
Clone the project
Do some work on a topic branch
On the project page, fork the project.
git remote add <remote> <fork-url>
It's usually easiest to push the topic branch rather than merging with the
master branch and pushing that. (Note that -u is not be needed if you're
working alone from your fork or on this branch in your fork.)
git push -u <fork> <topic>
Submit a pull request on GitHub or run git request-pull and email the output to
the project maintainer. The arguments to git request-pull are the remote branch
(e.g., origin/master) you want to merge your topic branch into and the URL or
shortname of your fork.
git request-pull <remote-tracking-branch> <fork>

If you want to work on multiple topics, don't work from previous topic branches.
Checkout the remote branch you want to base your work on, spawn a new topic
branch, make changes, then submit a pull request. Only the changes particular to
your new topic branch will appear in the pull request, and each request can be
approved or denied without affecting the other requests.
git fetch origin
git checkout -b featureB origin/master
...
git push myfork featureB
git request-pull origin/master myfork

If the original project tries to merge your work after some other patches, and
the merge fails, you can fetch the newest features, checkout your topic branch,
rebase on the main project's branch, resolve the conflicts, and force push.
git push -f <remote> <branch>: When the branch being pushed is not a direct
descendant of the branch already on the remote, a force push is required.

Or you can checkout a new branch based on the main project's branch, then do a
squashed merge of your topic branch rather than rebasing.
git checkout -b <branch> origin/master
git merge --squash <topic>
... More changes ...
git commit
git push myfork <branch>
Squashing takes all work on the merged branch and squashes it into a single
changeset, creating the equivalent of a merge without actually committing. You
can do additional work before creating the actual commit. Once you commit,
instead of having two parent commits, there will only be a single parent. Crazy,
right?  The main differences between squash and rebase are 1) squash doesn't
create a commit right away, enabling further work before committing; 2) squash
doesn't delete the branch you squash; 3) squashing creates a single commit,
whereas rebase replays all of your commits onto a different branch. Both,
however, produce a linear commit history with a single parent.

=== Public project over email ===

Skipping. Covers git format-patch and git send-email.

== Maintaining a project ==

=== Overview ===

Skipping email portion.

Add contributors repository as a remote, fetch, then checkout a remote-tracking
branch as a local (tracking) branch.
git checkout -b <branch> <remote>/<branch-remote>
Then investigate and merge locally before pushing to the main remote repository
(not the contributor's repository).

=== Investigating what changed ===

See the commits and their diffs (-p) in contrib but not master
git log -p contrib --not master
git log -p master..contrib
This shows changes grouped by commit. What about all changes cumulatively?

git diff accepts a commit/branch to compare the working trees between the
current and named commit. Say you want to compare a topic branch with the branch
it was spawned from. If the original branch has moved forward, git diff will
produce weird results. Assuming you're on topic and topic was spawned by master,
git diff master
will appear as if you're adding every change in topic and removing everything
unique to master. But there's another way.

To see all changes that would result from merging topic with master, you can
find the common ancestor of the branches and find the difference between that
and the topic
git diff (git merge-base contrib master) contrib
Or use the shorthand
git diff master...contrib
For git diff, the triple dots specify the changes the RHS has introduced
since its common ancestor with the LHS

=== Integrating contributed work ===

1. Merge topic branches into master.
2. Use master and develop branches, merging topic branches into the latter.
   Develop will be merged into master only when a stable point is reached. The
   merge will be a simple fast-forward. Project users can check out master for
   stability or develop for cutting-edge features.
3. Skip: Large-merging workflows

=== Cherry-picking ===

Alternatives to merging allow for a linear commit history. Rebasing was covered
earlier. Cherry-picking is like rebasing a single commit at a time. It takes the
patch introduced by a commit and tries to apply it to the current branch.

Skip the rest of this section. See
[[https://git-scm.com/book/en/v2/Distributed-Git-Maintaining-a-Project|section 5.3 of Git Pro]]
for information on rerere (auto-conflict resolution), signing and verifying
signed tags, creating archived releases for direct download, and the shortlog.

= Github =

Skip.

= Git Tools =

== Revision Selection ==

=== Short SHA-1 ===

Commit hashes can be shortened as long as they are unique. Usually 8-10
characters are sufficient, but --abbrev-commit removes guesswork
git log --abbrev-commit --pretty=oneline
Copy the desired hash
git show <commit>

=== Branch ===

git show <branch>
To get the SHA-1
git rev-parse <branch>

=== Reflog ===

git reflog: Log of where a reference pointed to locally (i.e., differs for
different contributors and is empty upon cloning)
git show HEAD@{<N>}: N HEADS ago
git reflog master@{yesterday}: See where master branch was yesterday
git reflog master@{2.months.ago}

=== Ancestry refs ===

git show HEAD^<N>: show the nth parent of HEAD, assuming there are multiple
parents (i.e., HEAD is a merge commit)
git show HEAD~<N>: Show the grandparent of the commit (if N=2), and so on
git show HEAD~3^2: Get the second parent of the great-grandparent

This syntax is useful when combined with a graph log to determine ancestry, e.g.
git log --pretty=format:'%h %s' --graph

=== Commit ranges ===

Single-space syntax: Get a range of commits reachable from either RHS or LHS

Double-dot syntax: Get a range of commits that are reachable from RHS but not
LHS (i.e., from RHS to but not including common ancestor if one exists)
git log origin/master..HEAD: Log of commits reachable from HEAD but not
origin/master (i.e., view what you're about to push to the remote, assuming
origin/master matches remote's master)
Git subsitutes HEAD if either side is missing:
git log origin/master..
git log ..origin/master

The double-dot syntax is limited to two refs. These are equivalent
git log refA..refB
git log ^refA refB
git log refB --not refA
But the latter two allow for more than two refs
git log refA refB ^refC
git log refA refB --not refC

Triple-dot syntax: All commits reachable by either but not both of two refs
(i.e. everything since but not including common ancestor if one exists):
git log --left-right master...experiment: Show commits either ref doesn't have
in common and indicate which ref they can be reached from via < or >

!!!Note that such descriptions only apply to git log.!!!

Git diff only operates on two commits max, and the behavior is somewhat opposite
with ranges. Git Pro talks about the "tip" of a branch, but this is wrongheaded.
A branch is a ref to a single commit.

..: Diff of both branches. Same as replacing the dots with
a space. I.e. full diff b/w both branches.
...: Replaces LHS with common ancestor ("merge base") of LHS and RHS. I.e.,
shows diff b/w comon ancestor and RHS

Source for disambiguation: https://stackoverflow.com/questions/7251477/what-are-the-differences-between-double-dot-and-triple-dot-in-git-dif/7256391#7256391

== Interactive staging ==

IDEs have faclities for this. E.g. see vim fugitive https://vi.stackexchange.com/questions/10368/git-fugitive-how-to-git-add-a-visually-selected-chunk-of-code

git add -i: Interactive staging (see `man git-add`, "INTERACTIVE MODE")
    * STATUS
    * UPDATE: Mix of STATUS and staging a whole file
    * REVERT: Unstage (or untrack) files: "... staged information for selected
      paths are reverted to that of the HEAD version."
    * ADD UNTRACKED: Begin tracking a file
    * PATCH: Choose parts of a file to stage. Use ? to see available keypresses.
    * DIFF: Review what will be committed, similar to git diff --cached

Note that u and r select something to be (un)staged, but you have to type e.g.
u<CR> 1,2<CR> <CR> to actually stage files 1 and 2. Between entering the
numbers and pressing ENTER, and pressing the following ENTER, the files to be
staged will be marked with asterisks to indicate they are selected for staging.
The subsequent ENTER actually stages them, hiding the asterisks and updating the
status information under the "staged" header.

git add -p: Same as PATCH in interactive mode, but without first starting
interactive mode. Also accepts individual file arguments.

!!! git reset -p: Undo any git add -p !!!

There are also git checkout -p and git stash save -p, which are apparently
explained in later sections.

== Stashing and cleaning ==

Skip (temporarily, this is important).

== Signing your work ==

Skip.

== Searching ==

Compared to normal grep, git grep can search through specific commits or tags,
while grep can only search through the working tree of a git repository.

git grep
    -n: Line number in each file
    -c: Count per file
    -p: Context (i.e., enclosing function or method) -- does this work for
    languages aside from C?

To find when, rather than where, a term was introduced, you can search with git
log and find the earliest result:
git log -S <term> --oneline
For more information, use the -G option.

git log -L :<term>:<file> : Shows the history of a line of code or function.
Yes, that's right! A line within a function (<term>)! Does this work for
languages other than C? According to the last paragraph of this section in Git
Pro, you can provide a regex to help Git match a function or method in your
language. From the example given, it looks like you pass the starting and ending
lines, surrounded by //, then surrounded by quotes if spaces are included, and
separated by commas. E.g.
git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c
Tells git log to look for changes between
unsigned long git_deflate_bound
and
}
within
zlib.c.
This is only a hypothesis, as I'm not sure wha the caret in ^} is for...
See the man page to figure it out.

== Changing the last commit ==

git commit --amend: Change last commit message and/or contents
NOTE: Don't amend a commit you've pushed, because it changes the SHA-1. This is
similar to recommendations about not rebasing commits you've pushed.

== Changing multiple commit messages ==

git rebase -i <commit>: Interactively rebase from the child of the specified
commit to HEAD
git rebase -i HEAD~: Edit HEAD
git rebase -i HEAD~2: Edit HEAD and its parent

Interactive rebase lists commits in chronological order, top to bottom, in
contrast got git log. It can be used for simple commit editing, reordering,
deletion, squashing, and splitting. See
[[https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History|the examples]].

Git no longer recommends filter-branch for extensive history alterations.
Instead use
[[https://github.com/newren/git-filter-repo#simple-example-with-comparisons|git-filter-repo]]

== Reset demystified ==

== Advanced merging ==

== Rerere ==

== Debugging with git ==

== Submodules ==

== Bundling ==

== Replace ==

== Credential Storage ==

= Customizing git =


= Dates in git =

Dates in git are largely undocumented, but I found a random source exploring its bounds.
Apparently it uses an internal library called approxidate.
Source: https://alexpeattie.com/blog/working-with-dates-in-git

TL;DR: Dates are super flexible. The following work:
    * today
    * 2.months.ago
    * "last tuesday"
    * 10-12-2020
    * "Apr 18 18:46:55 2020"
    * "Apr 18 2020 - 1 week"

These date formats can be passed to command flags like --since or --until, or
they can be used with Git's generic date filter: @(<date>)

E.g., git diff master@("yesterday") master@("1 year 6 months ago")

WARNING :Some date specs don't seem to work, so try phrasing the same query
multiple ways if you notice something odd.

WARNING: Git may guess dates incorrectly at times. E.g. git log --until=
    * 11.4.2020
    * 4.11.2020
both showed me commits in my dockervim project up until Apr 9 2020. I'm not sure
how to force a specific date format for input, so always check Git's output
against your input date. One way that seems to work is:
    * YYYY.MM.DD
Test that this format is consistently interpreted as such.

WARNING: git log displays author date (date of original commit), while git log
--since=<date> interprets its input as committer date (date patch was applied to
the project). What other areas of git does this affect? To see committer date in
the logs, use git log --format=fuller.

= Git log =

== pretty=FORMAT ==

oneline
    <sha1> <title line>
format:STRING
    STRING may contain literal characters, and formatting or commit-based placeholders
    formatting placeholders:
        %<(N)[,trunc|ltrunc||mtrunc]: Subsequent placeholder occupies N spaces, padding on right.
            Optionally truncate at beginning (ltrunc), middle (mtrunc), or end (trunc) if output is
            longer than N columns
        %>(N): Subsequent placeholder occupies N spaces, padding on left
    commit-based placeholders:
        %n: newline
        %h: abbreviated commit hash
        %an: author name
        %ar: author date, relative
        %cn: committer name
        %cr: commiter date, relative
        %s: subject
        %b: body

= globbing =

Glob special characters need to be escaped b/c both the shell and Git do filename expansion on globs. E.g., log/\*.log matches any .log files within log/, while \*~ removes files ending in ~.


Detached head state: New commits aren't associated with a branch and can only be
reached by the commit hash. You can avoid this by creating a new branch anytime
you return to a previous commit to make fixes. Occurs when you check out a past
commit without creating a branch. Why is it called this?

TODO: Write about this section onward

TODO: State-backed reopsitory?
